<html>
  <head>
    <title>Camera - Leap</title>
    <style>
      canvas { width: 100%; height: 100%; background-color: #f0; }
    </style>

  </head>
  <body>

    <div class="meny">
      <h2>Heres the div where i should be putting menu items</h2>
    </div>

    <div class="meny-arrow"></div>

    <div class="canvas"><div id="canvas">
    </div>


    <script src="three.js"></script>
    <script src="leap.js"></script>
    <script src="Hand.js"></script>
    <script src="Finger.js"></script>
    <script src="Lathe.js"></script>
    
    <script src="keyboard.js"></script>
    <script src="meny.min.js"></script>
    <script>

    //----------------------------------------------------------------------
    //MENU VARIABLES
    //----------------------------------------------------------------------
      var meny = Meny.create({
        // The element that will be animated in from off screen
        menuElement: document.querySelector( '.meny' ),

        // The contents that gets pushed aside while Meny is active
        contentsElement: document.querySelector( '.canvas' ),

        // [optional] The alignment of the menu (top/right/bottom/left)
        position: Meny.getQuery().p || 'bottom',

        // [optional] The height of the menu (when using top/bottom position)
        height: 200,

        // [optional] The width of the menu (when using left/right position)
        width: 260,

        // [optional] Distance from mouse (in pixels) when menu should open
        threshold: 40,

        // [optional] Use mouse movement to automatically open/close
        mouse: true,

        // [optional] Use touch swipe events to open/close
        touch: true
      });

    //initially set the menu to be closed.
    var menuStatus = false;
    //----------------------------------------------------------------------

    var container,scene,renderer,camera,cube;
    var debug_mode = true;
    var spheres = {};

    //-----------------------------------
    var debug;
    var collisionDebug;
    var controller = new Leap.Controller({enableGestures: true});
    //-----------------------------------
    var handIds = {};
    var handObj = {};

    var d2;
    var line;


    //------------------------------------
    var cameraRotationDegrees = 0;
    var cameraRotationDegreesUp = 0;
    var cameraRotationDegreesDown = 0;
    var started = false;
    var initialCameraPosition = 0;
    var finalCameraPosition = 0;
    var selectedItem = null;
    var transformationMode = false;

    //------------------------------------
    //flying variables
    //------------------------------------
    var isFlying = false;
    var palmOffset = new THREE.Vector3();
    var initialFlyingPosition;
    var newFlyingPosition;

    var weight = 0.0;;

    //------------------------------------


    //------------------------------------
    var MODES =  {
                        INITIAL : {value : 0, name: "INITIAL"},
                        HEIGHT : {value : 1, name: "HEIGHT"},
                        WIDTH : {value : 2, name: "WIDTH"},
                        FINISHED : {value : 3, name : "FINISHED"},
                        PULL : {value : 4, name : "PULL"},
                        PUSH : {value : 5, name : "PUSH"}
                      };
    var currentMode = MODES.INITIAL;
    var sculptingMode = MODES.PULL;

    var lathe;
    var openPalmCount = 0;
    var finishedStart = false;




    var collidables = [];

    main();

    


    function init()
    {
      //init camera, renderer and scene
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer();
      renderer.shadowMapEnabled = true;
      renderer.shadowMapSoft = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColorHex( 0x0099CC, 1 );
      container = document.getElementById('canvas');
      document.body.appendChild(container);
      //document.body.appendChild(renderer.domElement); 
      container.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 3000 );
      initCamera();

      


      var material = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

      initLight(scene, new THREE.Vector3(-20,600,30));
      //initLight(scene, new THREE.Vector3(50,0,-10));
      initLight(scene, new THREE.Vector3(-100,200,-10));


      //var g = new Lathe(scene,0,0,0);

    }

    function initLight(scene, position)
    {
      var light = new THREE.DirectionalLight();
      light.position.set(position.x, position.z, position.y);
      light.intensity = 0.9;
      light.castShadow = true;
      light.shadowCameraVisible = true;
      light.shadowDarkness = 0.4;
      light.shadowMapWidth = light.shadowMapHeight = 2048;
      light.shadowCameraNear = 100;
      light.shadowCameraFar = 800;
      light.shadowCameraLeft = -500;
      light.shadowCameraRight = 500;
      light.shadowCameraTop = 500;
      light.shadowCameraBottom = -500;
      light.visible = true;

      scene.add(light);
    }

    function initCamera()
    {
      camera.position.x = 0;
      camera.position.y = 150;
      camera.position.z = 400;
    }

    //-------------------------------------------------------------
    //CAMERA STUFF
    //-------------------------------------------------------------

    function plane()
    {
      var planeGeo = new THREE.PlaneGeometry(2000,2000,1,1);
      //var planeMat = new THREE.MeshLambertMaterial();
      planeGeo.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      //planeGeo.applyMatrix(new THREE.Matrix4().makeTranslation(0, -10, 0));
      var planeMat = new THREE.MeshBasicMaterial();

      return new THREE.Mesh(planeGeo, planeMat);
    }

    var leftStart = false;
    var rightStart = false;

      var debugFrame;

    function processHandInfo(frame)
    {
          debugFrame = frame;
        isFlying = true;
        leftStart = false;
        rightStart = false;
        openPalmCount = 0;

        if (frame.hands === undefined ) { 
          var handsLength = 0 
        } else {
          var handsLength = frame.hands.length;
        }
        
        for(id in handIds)
        {
          handIds[id] = false;
        }

        for (var handId = 0, handCount = handsLength; handId != handCount; handId++) 
        {
          var hand = frame.hands[handId];
          var posX = (hand.palmPosition[0]*1.5);
          var posY = (hand.palmPosition[2]*1)-600;
          var posZ = (hand.palmPosition[1]*1)-200;
          var rotX = (hand.rotation[1][2]*90);
          var rotY = (hand.rotation[1][1]*90);
          var rotZ = (hand.rotation[1][0]*90);
          //console.log(hand.id);
          

          /*
          if (!sphere) {
                spheres[hand.id] = hand.id;
          } else {

              moveSphere(sphereDiv, posX, posY, posZ, rotX, rotY, rotZ);
            
          }
          */
          if(handIds[hand.id] == undefined)
          {
            handObj[hand.id] = new Hand(scene);
            if(posX > 0)
            {
              handObj[hand.id].setSide(1);
            }
            else
            {
              handObj[hand.id].setSide(0);
            }
            scene.add(handObj[hand.id].palm);
            //console.log("about to make a new hand cube id: " + hand.id);
          }
          handObj[hand.id].palm.position = new THREE.Vector3(posX,posZ,posY);
          handObj[hand.id].palmNormal = new THREE.Vector3(hand.palmNormal[0], hand.palmNormal[1], hand.palmNormal[2]);
          

          if(handObj[hand.id].openPalm)
          {
            openPalmCount++;
          }
          
          handObj[hand.id].updateFingers(frame.hands[handId].fingers);

          handIds[hand.id] = true;

          //console.log(handObj[hand.id].noFingers);


          if(currentMode == MODES.INITIAL && openPalmCount == 2)
          {
            console.log("start the cylinder mesh");
            lathe = new Lathe(scene);
            currentMode = MODES.HEIGHT;
            console.log("going to height mode")
          }


          if(handObj[hand.id].side)
          {
            rightStart = handObj[hand.id];
          }
          else
          {
            leftStart = handObj[hand.id];
          }
          
          //if we're in the play mode and the user has an open left hand
          if(currentMode == MODES.FINISHED && handObj[hand.id].side == false)
          {
            if(handObj[hand.id].openPalm )
            {
              //if the menu is closed, open the menu;
              if(!meny.isOpen())
              {
                meny.open();
              }
            }
            else
            {
              if(meny.isOpen())
              {
                meny.close();
              }
            }
          }
          else
          {
            if(handsLength < 2)
            {
              if(meny.isOpen())
              {
                meny.close();
              }
            }
          }

        }



        
        //console.log(isFlying);

        //deleting
        for (handId in handIds) {
          //console.log("handId " + handId);
          //console.log("true? :: " + handIds[handId]);
          if (!handIds[handId]) {
            //console.log("deleting a hand cube id: " + handId);
            handObj[handId].onRemove();
            //scene.remove(handObj[handId].palm);
            delete handIds[handId];
            //delete handObj[handId];
          }
        }
    }


    function rotateMesh(deg)
    {
      debugCylinder.rotation.y = deg;
    }

    function handleGestures(gesturesArray)
    {

      for(gesture in gesturesArray)
      {
        var hand = handObj[gesturesArray[gesture].handIds[0]];
        if(handObj[gesturesArray[gesture].handIds[0]] != undefined)
        {
          var side = handObj[gesturesArray[gesture].handIds[0]].side == 1 ? true : false;
        }
        switch(gesturesArray[gesture].type)
        {
          case "swipe" : 

            //console.log(gesturesArray[gesture].direction);
            if(gesturesArray[gesture].speed > 600.0)
            {
            //console.log(hand.swipeDirection);
            //cameraRotationDegrees += (gesturesArray[gesture].position[0] - gesturesArray[gesture].startPosition[0]) / 40.0;
            //rotateCamera(cameraRotationDegrees);
            }
            break;
          case "circle" :
          /*
          if(side)
          {
            
            console.log("right: did a circle");
          }
          else
          {
            console.log("left: did a circle")

          }
          */
          if(side)
          {
            break;
          }
          d2 = gesturesArray[gesture];
          if(gesturesArray[gesture].state != "stop")
          {
            if(gesturesArray[gesture].normal[2] < 0)
            {
              //camera.position.x += 2;
              cameraRotationDegrees += .01;
              console.log("clockwise rotation");

            }
            else
            {
              //camera.position.x -= 2;
              cameraRotationDegrees -= .01;
              console.log("counter clockwise rotation"); 
            }
              
          }
          //console.log(gesturesArray[gesture]);
          //console.log(cameraRotationDegrees);
          
            rotateMesh(cameraRotationDegrees);
          return;
          break;
          case "keyTap" :
          if(side)
          {
            console.log("right: did a keytap");
          }
          else
          {
            //console.log("left: did a keytap")
          } break;
          case "screenTap" :
          if(side)
          {
            //console.log("right: did a screentap");
            debugCylinder.material.wireframe = false;
          }
          else
          {
            //console.log("left: did a screentap")
            debugCylinder.material.wireframe = true;
          } break;
          default : //console.log("new gesture" + gesturesArray[gesture].type); 
        }
        break;
      }
    }



    function rayCastPalm(frame)
    {
      for(id in handObj)
      {
        handObj[id].update(camera, frame);

      }

      if(currentMode == MODES.HEIGHT && rightStart && leftStart)
          {
            
            lathe.setHeight(rightStart.palm.position.y - leftStart.palm.position.y);
            lathe.scale();
            if(leftStart.noFingers)
            {
              console.log("going to width mode");
               //currentMode = MODES.WIDTH;
               currentMode = MODES.FINISHED;
            }
          }

        if(currentMode == MODES.WIDTH && rightStart && leftStart)
        {
          lathe.setWidth(rightStart.palm.position.x - leftStart.palm.position.x - 100);
          lathe.scale();







          if(rightStart.noFingers)
          {
            console.log("finished");
            currentMode = MODES.FINISHED;
          }
        }
        
        if(currentMode == MODES.FINISHED &&  (leftStart || rightStart))
        {
          ///checkMeshCollisions(leftStart);
          checkMeshCollisions(rightStart);
        }
    }

    controller.loop(function(frame) {
      var startX = camera.position.x;
      var startY = camera.position.y;
      var startZ = camera.position.z;
      var state  = null;
      var startFrame = null;


      // if there was a gesture in this frame, handle it
      if(frame.gestures.length > 0)
      {
        //console.log(frame.gestures);
        handleGestures(frame.gestures);
      }


      
      if(debug_mode)
      {
        processHandInfo(frame);
      }
      
      rayCastPalm(frame);

      if (frame.valid) {
        debug = frame;

        if (state == null) {
          if (frame.hands.length > 0 && frame.pointables.length <= 1) {
            
          }
        } else if (state == 'moving') {
          var t = startFrame.translation(frame);
          cube.position.x = t[0] * 10 + startX;
          cube.position.y = t[1] * 10 + startY;
          cube.position.z = t[2] * 10 + startZ;
          if (frame.hands.length == 1 || frame.pointables.legnth > 1) {
            state = null;
          }
        }
      }
      renderer.render(scene, camera);
    });


    var fingerDebug;
    var previousFaces = [];
    
    function checkMeshCollisions(handObject)
    {
      /*
      debugCylinder.updateMatrixWorld();
      for(vertex in lathe.mesh.geometry.vertices)
      {
        

        var what = Math.pow(
        Math.pow(debugCylinder.geometry.vertices[vertex].x - handObject.palm.position.x, 2) +
        Math.pow(debugCylinder.geometry.vertices[vertex].y - handObject.palm.position.z, 2) +
        Math.pow(debugCylinder.geometry.vertices[vertex].z - handObject.palm.position.y, 2), .5) ;
        //console.log(debugCylinder.geometry.vertices[vertex]);
        //console.log(handObject.palm.position);
        //console.log(what);
        //console.log(vertex);
        //if(debugCylinder.geometry.vertices[vertex].position.distanceToSquared(handObject.palm.position) <= 1000 )
        if(false)
        {
          //console.log("shit just got real");
        }
        else 
        {
          //console.log(debugCylinder.position.distanceToSquared(handObject.palm.position));
          //console.log(handObject.palm.position);
          //console.log(debugCylinder.position);
          //return;
        }
      }

      */
        debugCylinder.geometry.__dirtyVertices = true;
        debugCylinder.geometry.dynamic = true;
        var tempMatrix = new THREE.Matrix4();
        //var c = Math.cos( cameraRotationDegrees ), s = Math.sin( cameraRotationDegrees );
        tempMatrix.makeRotationY(-cameraRotationDegrees);
        //tempMatrix = tempMatrix.getInverse(tempMatrix);

        for(face in previousFaces)
        {
          previousFaces[face].color.setRGB(1,1,1);
        }

        previousFaces = [];

        for(finger in handObject.fingers)
        {
          //console.log(handObj[hand].fingers[finger].position);
          var ray = new THREE.Raycaster(handObject.fingers[finger].position, handObject.fingers[finger].direction)
          var collisionResults = ray.intersectObject(debugCylinder);
          fingerDebug = handObject.fingers[finger];

          if(collisionResults.length > 0)
          {
            previousFaces.push(debugCylinder.geometry.faces[collisionResults[0].faceIndex]);
            //previousFaces.push(debugCylinder.geometry.faces[collisionResults[0].faceIndex+1]);
            //previousFaces.push(debugCylinder.geometry.faces[collisionResults[0].faceIndex-1]);
            debugCylinder.geometry.faces[collisionResults[0].faceIndex].color.setRGB(collisionResults[0].distance/100,collisionResults[0].distance/100,collisionResults[0].distance/100);
            /*
            debugCylinder.geometry.faces[collisionResults[0].faceIndex+1].color.setRGB(collisionResults[0].distance/100,collisionResults[0].distance/100,collisionResults[0].distance/100);
            debugCylinder.geometry.faces[collisionResults[0].faceIndex-1].color.setRGB(collisionResults[0].distance/100,collisionResults[0].distance/100,collisionResults[0].distance/100);
            */
            debugCylinder.geometry.colorsNeedUpdate = true;
          }
          if ( collisionResults.length > 0 && collisionResults[0].distance < 30 ) 
            {
              //console.log(" Hit ");
              collisionDebug = collisionResults[0];

              //collisionResults[0].face.color.setRGB( Math.random(), Math.random(), Math.random());
              /*
              debugCylinder.geometry.vertices[collisionResults[0].face.a].subSelf(collisionResults[0].face.normal.clone());          
              debugCylinder.geometry.vertices[collisionResults[0].face.b].subSelf(collisionResults[0].face.normal.clone());
              debugCylinder.geometry.vertices[collisionResults[0].face.c].subSelf(collisionResults[0].face.normal.clone());
              debugCylinder.geometry.vertices[collisionResults[0].face.d].subSelf(collisionResults[0].face.normal.clone());
              */
              var tempDirection = tempMatrix.multiplyVector3(handObject.fingers[finger].direction);
              
              if(sculptingMode == MODES.PULL)
              {
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex].b].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex].c].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex].d].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex].a].subSelf(tempDirection);

                /*
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex+1].b].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex+1].c].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex+1].d].subSelf(tempDirection);
                debugCylinder.geometry.vertices[debugCylinder.geometry.faces[collisionResults[0].faceIndex+1].a].subSelf(tempDirection);
                */
                //debugCylinder.geometry.faces[collisionResults[0].faceIndex];
              }
              else if(sculptingMode == MODES.PUSH)
              {
                debugCylinder.geometry.vertices[collisionResults[0].face.b].addSelf(tempDirection);
                debugCylinder.geometry.vertices[collisionResults[0].face.c].addSelf(tempDirection);
                debugCylinder.geometry.vertices[collisionResults[0].face.d].addSelf(tempDirection);
                debugCylinder.geometry.vertices[collisionResults[0].face.a].addSelf(tempDirection);
              }


              //debugCylinder.geometry.__dirtyVertices = true;
              //debugCylinder.geometry.dynamic = true;


              var n, nl, v, vl, vertex, f, fl, face, vA, vB, vC,
              cb = new THREE.Vector3(), ab = new THREE.Vector3();

              face = collisionResults[0].face;

              vA = debugCylinder.geometry.vertices[ face.a ];
              vB = debugCylinder.geometry.vertices[ face.b ];
              vC = debugCylinder.geometry.vertices[ face.c ];

              cb.sub( vC, vB );
              ab.sub( vA, vB );
              cb.crossSelf( ab );

              cb.normalize();

              face.normal.copy( cb );

            }
          else if (collisionResults.length > 0)
          {
            //console.log(collisionResults[0].distance);
          }
        }

        debugCylinder.geometry.verticesNeedUpdate = true;
              //debugCylinder.geometry.colorsNeedUpdate = true;
        //debugCylinder.geometry.computeFaceNormals();
    }


    function main()
    {
      init();
    }
    </script>
    <div id="out"></div>
  </body>
</html>
